{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Promise简单总结","slug":"Promise简单总结","date":"2018-05-01T13:25:18.994Z","updated":"2018-05-01T14:09:04.405Z","comments":true,"path":"2018/05/01/Promise简单总结/","link":"","permalink":"http://yoursite.com/2018/05/01/Promise简单总结/","excerpt":"","text":"前言Promise代表一个异步操作。具体通过下面的Promise实例来说明。 创建一个Promise实例1234567891011121314const MyPromise = new Promise((resolve,reject) =&gt; &#123; ... if (/*异步操作成功*/) &#123; resolve(value) &#125; else &#123; reject(error) &#125;&#125;)MyPromise.then((value) =&gt; &#123; ...&#125;).catch((error) =&gt; &#123; ...&#125;) Promise构造函数接收一个参数，该参数是一个异步执行的函数。这个函数有两个参数resolve和reject。 当异步操作执行成功时将会调用resolve，resolve的作用是将promise对象的状态由“未完成”变为“成功”，此时将会调用resolved（成功）状态的回调函数，该回调函数是then方法的第一个参数。该回调函数的参数值可通过设置resolve函数的参数传递过来。 当异步操作执行失败时将会调用reject，reject的作用是将promise对象的状态由“未完成”变为“失败”，此时将会调用rejected（失败）状态的回调函数，该回调函数是then方法的第二个参数。但一般不会使用then的第二个参数，而是使用catch方法。因为catch方法不仅可以捕获到一开始promise对象中异步操作失败的错误，还能捕获到前面then方法中的错误。 使用Promise封装简化版axios中get方法12345678910111213141516171819const MyAxios = &#123; get: function(url) &#123; return new Promise((resolve,reject) =&gt; &#123; const XHR = new XMLHttpRequest() XHR.open(&apos;GET&apos;,url,true) XHR.onreadystatechange = function() &#123; if (this.readyState !== 4) &#123; return &#125; if (this.status === 200) &#123; resolve(this.response) &#125; else &#123; reject(new Error(this.statusText)) &#125; &#125; XHR.send() &#125;) &#125;&#125;","categories":[],"tags":[]},{"title":"关于scoped","slug":"关于scoped","date":"2018-05-01T12:32:31.521Z","updated":"2018-05-01T13:19:34.256Z","comments":true,"path":"2018/05/01/关于scoped/","link":"","permalink":"http://yoursite.com/2018/05/01/关于scoped/","excerpt":"","text":"说明不得不说，scoped有时算是一个坑，因为在使用vue有时会出现css样式无效的情况，无论使用!important还是行内样式都没有效果。为什么会出现这种情况，我们接下来来讨论下。 scoped原理要讨论上面的情况，首先我们得知道scoped的原理。vue中的组件使用了类似Shadow Dom的思想，使其封闭起来，通过scoped使组件之间的样式不会相互影响。而对于scoped的原理，简单来说就是给组件内的html标签加上一个属性，并且让css选择器也选择上改属性，从而达到样式封装的效果，让css变得有作用域。123456789&lt;style&gt;.example[data-v-f3f3eg9] &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;example&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; 关于动态添加的dom样式不生效，很多种情况都是出现在动态添加的dom,这是因为动态添加的dom是不会加上上面所说的属性的，而相应的Css则会加上该属性，所以该样式自然就不会生效了。这时候使用全局样式是经常可以解决问题的，但是需要注意的是，使用全局样式也就意味着有可能会影响到其它的组件。可以在一个组件中同时使用有作用域和无作用域的样式1234567&lt;style&gt;/* 全局样式 */&lt;/style&gt;&lt;style scoped&gt;/* 本地样式 */&lt;/style&gt; 关于深度作用选择器scoped中的样式只会影响该组件和子组件的根节点，如果想要让scoped样式也作用于子组件的其它元素，可以使用深度作用选择器。对于有些类似sass的预编译器可能无法解析 &gt;&gt;&gt; ，这时可以使用/deep/操作符取代。123&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt; 上述代码将会编译成123&lt;style scoped&gt;.a[data-v-f3f3eg9] .b &#123; /* ... */ &#125;&lt;/style&gt;","categories":[],"tags":[]},{"title":"Vue使用axios上传文件","slug":"Vue使用axios上传文件","date":"2018-05-01T12:18:47.677Z","updated":"2018-05-01T12:28:48.667Z","comments":true,"path":"2018/05/01/Vue使用axios上传文件/","link":"","permalink":"http://yoursite.com/2018/05/01/Vue使用axios上传文件/","excerpt":"","text":"模板1&lt;input type=&quot;file&quot; ref=&quot;myFile&quot; &gt; script1234567891011121314let prod = new FormData()let file = this.$refs.myFile.files[0]prod.append(&apos;file&apos;,file)let config = &#123; headers: &#123; &apos;Content-Type&apos;: &apos;multipart/form-data&apos; &#125;&#125;axios.post(url,prod,config).then(() =&gt; &#123; ...&#125;).catch(() =&gt; &#123; ...&#125;)","categories":[],"tags":[]},{"title":"vuex的v-model双向绑定","slug":"vuex的v-model双向绑定","date":"2018-04-30T13:46:09.730Z","updated":"2018-04-30T14:14:10.011Z","comments":true,"path":"2018/04/30/vuex的v-model双向绑定/","link":"","permalink":"http://yoursite.com/2018/04/30/vuex的v-model双向绑定/","excerpt":"","text":"说明vuex思想中的state是只能通过mutation改变的，所以如果想让state和v-model进行双向绑定，可以通过调用mutation来改变state，同时配合computed达到双向绑定的效果。 Vuex123456789state: &#123; mes: &apos;mes&apos;&#125;mutation: &#123; updateMes: (state,data) =&gt; &#123; state.mes = data &#125;&#125; 模板1&lt;input type=&quot;text&quot; v-model=&quot;mes&quot;&gt; script12345678910computed: &#123; mes: &#123; get () &#123; return this.$store.state.mes &#125;, set (value) &#123; this.$store.commit(&apos;updateMes&apos;,value) &#125; &#125;&#125;","categories":[],"tags":[]}]}